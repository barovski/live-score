
d3.select('body')
d3.selectAll('body')

elem.attr('key', 'value')
elem.attr({key1 : value1, key2 : value2})
elem.style({key : value})

elem.classed('class-name', true) //true - add, false - remove

elem.html('html content')
elem.append('new elem')
elem.remove()

--------

var dataset = [8, 48, 14, 31, 23];

var svg = d3.select('body').append('svg').attr({
    width : 500px,
    height : 500px
});

svg.selectAll('rect')
    .data(dataset)  // binds data to the previous selection
    .enter()  // creates placeholders to insert data
    .append('rect')
    .attr({
        x: function (d, i) {return i * 100},
        y: 0,
        width: 100,
        height: function(d) {return d;},
        fill: 'orange'
    });

-------
How selection works:

The keys determine the enter selection in the following manner:
the keys of elements in the specified data array (which, in our examples is pdata) are compared with keys of the
elements in the existing selection (the selection returned by .selectAll("p") method).
Any element in the specified data array whose key is different from keys of all the the existing elements,
becomes a part of the enter selection. If the key of a new element matches the key of one of the existing elements
then it is NOT a part of the enter selection.

Neither example above specifies an explicit key function.
Hence, each elements key is its index in the array.
In Example 1, selectAll("p") returns an empty array;
there are no existing elements and consequently set of keys of existing elements is empty.
The keys of elements in pdata, i.e., elements 10, 12, 6, 8 and 15 are 0, 1, 2, 3, and 4 respectively.
Since all these have keys that are different from the keys of all the existing elements, they all become part of the enter selection.

On the other hand, in Example 2, .selectAll("p") returns an array with two elements with keys 0 and 1 respectively.
The keys of elements in pdata, i.e., elements 10, 12, 6, 8 and 15 are 0, 1, 2, 3, and 4 respectively.
Since elements 10 and 12 have the same keys as keys of elements in the existing selection, 10 and 12 do not become
part of the enter selection.

Methods .enter.append("p") create as many <p>...</p> elements as the number of elements in the enter selection
(see the previous step). The argument of .append() specifies the type of element to be created.

since elements 10 and 12 are not part of the enter selection,
no paragraph elements are created for them and they do not show up in the output.

D3 creates a bunch of <foo> elements, one for each entry in the array. More importantly,
it also associates the data for each entry in the array with that DOM element, as a __data__ property

Anything not within selection.enter() or selection.exit() is considered part of the “update” operation.
The “update” operation is also called immediately after “enter”, and updates can easily be animated



By default, D3 uses the index of the data in the data array to compare the data set with DOM elements.
This isn’t always ideal — but thankfully, you can pass a second (optional) parameter when assigning data to
a selection (when calling the .data() function):

var dataset = [{ id: 2553, value: 35 }, { id: 2554, value: 13 }];

var lines = d3.select("body").append("svg").selectAll("line")
  .data(dataset, function (d) { return d.id; });

-------

d3.range(upper-limit) -> returns an array

-------

var fs=["10px","20px","30px"];
d3.selectAll("p").data(fs).style("font-size",function(d) {return d;})

------

d3.select("body").selectAll("*").remove()

and remove everything below the body.

--------
d3.select("body").selectAll("wootwoot")
.data(text).enter().append("p").html(String)

This actually works. Why?
There are actually 0 elements of type “wootwoot” in our document, which may or may not surprise you.
There are still 3 items in the dataset, so enter() returns space for 3 new elements.
the next append subsequently creates 3 p elements, which are populated by the html method.


--------

But what’s really interesting is what would happen if you were to run that statement again – nothing. try it. See?
Why is that? Well, on your first go, at a point where there are no h1 elements yet, it works the standard way – you do a selectAll
 that returns nothing, you bind a dataset with more elements,
 then enter prepares space for the unmatched elements – 1 in our case – and then append creates that element.
 You may notice that the html part doesn’t use the data.
When you run it again, the selectAll finds one h1 element, there’s still one item in the dataset,
so enter won’t find any unmatched element, so the subsequent append is ignored.

So, you can run this kind of thing in a loop safely, it will only do what it’s supposed to do on the first go,
it will be ignored afterwards. Don’t be afraid to use this construct for all the unique parts of your visualization,
so you won’t have to worry about creating them multiple times.

-----
